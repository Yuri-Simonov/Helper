import { IInfo } from '@types';

export const COMPONENTS_LIFECYCLE: IInfo = {
    title: 'Жизненный цикл компонента (Angular hooks)',
    body: `<p>
                Каждый компонент имеет свой жизненный цикл, где на каждом этапе цикла вызываются соответствующие методы,
                так называемые хуки (Angular Hooks).
            </p>
            <p>
                Также стоит помнить, что
                <span class="attention"> сначала инициализируется конструктор класса компонента</span>, то есть,
                создается экземпляр компонента, и только после этого компонент начинает свой жизненный цикл. В
                конструкторе класса задаются (при необходимости) стартовые параметры или логика, которые сработают еще
                до вызова методов жизненного цикла. Также здесь внедряются зависимости, необходимые для работы текущего
                компонента. Если ничего из этого не нужно компоненту, то конструктор класса можно и вовсе не писать.
            </p>
            <p>Ниже перечислены все методы жизненного цикла компонента в порядке их вызова.</p>
            <ul>
                <li>
                    <p>
                        <span class="attention">ngOnChanges</span> - вызывается после того, как были проверены значения
                        входных свойств класса компонента, и до того, как был проверен шаблон текущего компонента.
                    </p>
                    <p>
                        У данного метода есть одна отличительная особенность от других методов жизненного цикла - это
                        <span class="attention"
                            >опциональный параметр <code>changes</code> с типом <code>SimpleChanges</code></span
                        >. Он представляет собой объект, внутри которого присутствуют поля, по названию совпадающие с
                        параметрами, которые текущий компонент получает от родителя через декоратор
                        <code>@Input&#40;&#41;</code>.
                    </p>
                    <p>Пример такого объекта, когда от родителя мы получаем свойство <code>title</code>:</p>
<pre><code class="language-typescript">{
	title {
		currentValue: 'Какое-то текущее значение свойства title',
		firstChange: true, // если это первое значение поля title, будет true, иначе false
		previousValue: undefined // если это первое значение поля title, то предыдущего еще не было
	}
}</code></pre>
                    <p>
                        Стоит также иметь ввиду, что метод <code>ngOnChanges</code> вызывается
                        <span class="attention">
                            только если есть входные параметры через декоратор <code>@Input&#40;&#41;</code>
                        </span>
                        у текущего компонента.
                    </p>
                </li>
                <li>
                    <p>
                        <span class="attention">ngOnInit</span> - вызывается единожды после того, как Angular впервые
                        проверил все свойства компонента, связанные с данными, и до того, как был проверен шаблон
                        текущего компонента.
                    </p>
                    <p>Пример свойства компонента, связанного с данными:</p>
<pre><code class="language-typescript">// класс компонента
title: string = 'Какой-то заголовок';</code></pre>
<pre><code class="language-html">&lt;!-- шаблон компонента -->
&lt;p>{{ title }}&lt;/p></code></pre>
                    <p>
                        Вот как только Angular проверит в данном случае это свойство, вот тогда и будет вызван метод
                        <code>ngOnInit</code>.
                    </p>
                    <p>
                        Если у компонента нет каких-либо входных параметров через декоратор
                        <code>@Input&#40;&#41;</code>, как это часто бывает в родительских компонентах, то метод
                        <code>ngOnChanges</code> не вызывается, следовательно, метод <code>ngOnInit</code> вызовется
                        первым после запуска жизненного цикла компонента.
                    </p>
                </li>
                <li>
                    <p><span class="attention">ngDoCheck</span> - вызывается при любых изменениях в компоненте.</p>
                    <p>У данного метода несколько сценариев вызова:</p>
                    <ul>
                        <li>
                            Если происходит инициализация компонента, то метод <code>ngDoCheck</code> вызовется после
                            вызова метода <code>ngOnInit</code>, т.е. произойдет реагирование на установку свойств
                            компонента;
                        </li>
                        <li>
                            Если ранее метод <code>ngOnInit</code> уже вызывался, т.е. компонент уже хотя бы раз прошел
                            все этапы жизненного цикла (не считая метод <code>ngOnDestroy</code>, отвечающий за удаление
                            компонента из DOM-дерева), то метод <code>ngDoCheck</code> будет вызываться каждый раз после
                            вызова метода <code>ngOnChanges</code>, т.е. произойдет реагирование на изменение входных
                            свойств компонента;
                        </li>
                        <li>
                            В добавок к этому, данный метод также будет вызываться всякий раз, когда будет происходит
                            изменение одного или нескольких внутренних свойств или случаться какое-то событие в
                            компоненте, которое влияет на данные одного или нескольких свойств этого компонента. Тут уже
                            будет происходить реагирование на изменения, которые нашел механизм
                            <code>Change Detection</code>.
                        </li>
                    </ul>
                </li>
                <li>
                    <p>
                        <span class="attention">ngAfterContentInit</span> - вызывается единожды после того, как Angular
                        полностью инициализирует все содержимое, которое заключено между его тегами в месте вызова этого
                        компонента. Это содержимое в дочернем компоненте подставляется вместо элемента
                        <code>ng-content</code>.
                    </p>
                    <p>
                        Даже если в компоненте нет элемента <code>ng-content</code>, данный метод все равно вызовется
                        при инициализации компонента.
                    </p>
                </li>
                <li>
                    <p>
                        <span class="attention">ngAfterContentChecked</span> - вызывается после того, как механизм
                        <code>Change Detection</code> завершил проверку всего содержимого, заключенного между тегами
                        компонента в месте его вызова. Опять же, это содержимое подставляется вместо элемента
                        <code>ng-content</code> уже в самом компоненте.
                    </p>
                    <p>По последовательности вызовов среди методов жизненного цикла у него есть 2 сценария:</p>
                    <ul>
                        <li>
                            При инициализации компонента метод <code>ngAfterContentCheck</code> вызывается по
                            очередности после вызова метода <code>ngAfterContentInit</code>;
                        </li>
                        <li>
                            Все последующие разы данный метод будет вызываться по очередности после метода
                            <code>ngDoCheck</code>.
                        </li>
                    </ul>
                </li>
                <li>
                    <p>
                        <span class="attention">ngAfterViewInit</span> - вызывается единожды после того, как Angular
                        полностью инициализирует представление компонента. Под представлением понимается содержимое
                        шаблона компонента, включая шаблоны других компонентов, которые в нем присутствуют;
                    </p>
                    <p>
                        В зависимости от того, является ли текущий компонент родительским для какого-то другого
                        компонента или нет, поведение метода <code>ngAfterViewInit</code> будет немного отличаться.
                    </p>
                    <p>
                        Допустим у нас есть родительский и дочерний компоненты (app.component.ts и child.component.ts
                        соответственно):
                    </p>
<pre><code class="language-html">&lt;!-- шаблон app.component.ts -->
&lt;app-child>&lt;/app-child></code></pre>
<pre><code class="language-html">&lt;!-- шаблон child.component.ts -->
&lt;p>Простой шаблон без использования других компонентов в нем&lt;/p></code></pre>
                    <p>
                        При таком сценарии, в момент инициализации компонента, консоль браузера будет выглядеть
                        следующим образом:
                    </p>
                    <img
                        class="large-img"
                        src="./assets/img/angular/component/example_ng_after_view_init.jpg"
                        alt="example ngAfterViewInit"
                    />
                    <p>
                        Сперва у нас вызывается родительский конструктор, затем дочерний. Потом родительский компонент
                        начинает свой жизненный цикл и доходит до метода <code>ngAfterContentChecked</code>. После него
                        запускается уже жизненный цикл дочернего компонента. Полностью его проходит и только после него
                        вызывается родительские методы <code>ngAfterViewInit</code> и <code>ngAfterViewChecked</code>.
                    </p>
                    <i class="subtitle">Почему так происходит?</i>
                    <p>
                        Метод <code>ngAfterViewInit</code> вызывается после того, как инициализируется содержимое
                        шаблона компонента, включая шаблоны других компонентов, которые в нем присутствуют.
                    </p>
                    <p>
                        Т.к. в шаблоне дочернего компонента <code>app-child</code> у нас нет других компонентов, поэтому
                        жизненный цикл при инициализации прошел полностью сразу.
                    </p>
                    <p>
                        В родительском же шаблоне ситуация иная, т.к. добавлен в него дочерний компонент. Поэтому он
                        дождался пока полностью пройдет инициализация шаблона дочернего компонента и своего шаблона в
                        целом и только после этого продолжил свой жизненный цикл.
                    </p>
                    <p>
                        Иначе говоря,
                        <span class="attention">
                            каждый родитель в дереве компонентов будет ждать полное выполнение жизненного цикла всех
                            своих дочерних компонентов, чтобы полностью пройти свой собственный жизненный цикл при
                            инициализации</span
                        >. И так пока цепочка жизненных циклов не дойдет до корневого компонента.
                    </p>
                </li>
                <li>
                    <p>
                        <span class="attention">ngAfterViewChecked</span> - вызывается после того, как механизм
                        <code>Change Detection</code> завершит проверку представления компонента на наличие изменений.
                    </p>
                    <p>По последовательно вызовов среди методов жизненного цикла у него есть 2 сценария:</p>
                    <ul>
                        <li>
                            При инициализации компонента метод <code>ngAfterViewChecked</code> вызывается после вызова
                            метода <code>ngAfterViewInit</code>;
                        </li>
                        <li>
                            Все последующие разы данный метод будет вызываться по очередности после метода
                            <code>ngAfterContentChecked</code>.
                        </li>
                    </ul>
                </li>
                <li>
                    <span class="attention">ngOnDestroy</span> - вызывается в момент удаления компонента из DOM-дерева.
                    На данном этапе
                    <span class="attention"
                        >следует отписываться от данных типа <code>Observable</code> и обработчиков событий, чтобы
                        избежать утечек памяти</span
                    >.
                </li>
            </ul>`,
    selected: false,
    lastUpdate: '08.02.2024',
    footerLinks: [
        {
            path: 'https://youtu.be/Nnf6gtAY0vc',
        },
    ],
};
