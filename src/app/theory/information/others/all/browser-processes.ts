import { IInfo } from 'src/app/shared/interfaces';

export const BROWSER_PROCESSES: IInfo = {
    title: 'Процессы, происходящие в браузере после ввода URL в адресную строку и нажатия клавиши Enter',
    body: `<p>
                Когда мы вводим URL в адресную строку браузера и жмём Enter, браузер проходит несколько шагов прежде,
                чем показать нам отрисованную страницу:
            </p>
            <i class="subtitle">1. Парсинг адреса и поиск сервера</i>
            <p>
                Сперва браузер начинает парсить введенный нами адрес, чтобы понять какой домен ему нужно открыть. Через
                DNS определяется IP-адрес сервера. Если IP-адрес есть в кэше браузера — берётся оттуда, иначе делается
                запрос к DNS-серверу.
            </p>
            <q
			>DNS (Domain Name System) — это как «телефонная книга интернета». Когда мы вводим, например, google.com,
                браузеру нужно узнать реальный IP-адрес сервера (например, 142.250.74.206). DNS и отвечает: «по этому
                имени — вот этот IP».
            </q>
            <i class="subtitle">2. Установление соединения</i>
            <p>
                Далее браузер открывает TCP-соединение с сервером и договаривается с ним о шифровании (TLS, если HTTPS).
                После этого можно безопасно обмениваться данными.
            </p>
            <q
                >TCP (Transmission Control Protocol) — это способ передачи данных по интернету. Он гарантирует, что
                данные дойдут без ошибок и в правильном порядке. Можно представить, как «доставка посылок с уведомлением
                о получении».</q
            >
            <q
                >TLS (Transport Layer Security) — это шифрование поверх TCP. Оно нужно, чтобы никто не мог подглядеть
                или подменить данные по пути.<br />
                HTTPS = HTTP + TLS.</q
            >
            <i class="subtitle">3. Отправка HTTP-запроса</i>
            <p>
                Далее делается HTTP-запрос на сервер. Обычно это GET-запрос. В запросе указываются заголовки, куки, язык
                и т.д.
            </p>
            <i class="subtitle">4. Получение ответа от сервера</i>
            <p>
                В ответе сервер возвращает HTML-документ, а также заголовки: тип содержимого, правила кэширования,
                политики безопасности.
            </p>
            <i class="subtitle">5. Парсинг HTML и загрузка ресурсов</i>
            <p>
                Имея HTML-документ, браузер начинает строить DOM-дерево, параллельно качает стили, скрипты, медиа-данные
                (картинки, видео и тд).
            </p>
            <p>Загрузка стилей не блокирует парсинг HTML, но блокирует рендеринг.</p>
            <q
                >Почему продолжается парсинг html-документа, но блокируется отрисовка пока не загрузятся стили? Логика
                простая: браузер может прочитать весь HTML, но без стилей он не знает, что скрыто (display: none), что
                где расположено и как выглядит. Поэтому рендер блокируется.</q
            >
            <p>
                Скрипты могут блокировать парсинг, если они указаны в теге <code>head</code> и не содержат атрибут
                <code>defer</code> или <code>async</code>. Если скрипты расположены непосредственно перед закрытием тега
                <code>body</code>, как это делается в классическом варианте, то скрипты не блокируют дальнейшую
                отрисовку.
            </p>
            <q
                >Обычный тег script без атрибутов блокирует HTML-парсинг. Браузер сначала загрузит и выполнит его, и
                только потом продолжит строить DOM-дерево.</q
            >
            <q
                >defer — говорит браузеру: «загружай скрипт параллельно, но выполни его только после того, как будет
                полностью построено DOM-дерево».</q
            >
            <q
                >async — «загружай параллельно и выполняй сразу, как только скачаешь» (может нарушить порядок
                скриптов).</q
            >
            <i class="subtitle">6. Построение CSSOM и Render Tree</i>
            <p>После того как было построено DOM-дерево, начинается построение дерева стилей (CSSOM).</p>
            <p>
                Имея готовые DOM + CSSOM, получаем Render Tree. На основе него браузер понимает, какие элементы и как
                нужно отобразить.
            </p>
            <q
                >Render Tree - «рабочая версия DOM-дерева для отрисовки» (DOM + CSSOM = Render Tree), которая включает
                только видимые элементы и их реальные стили.</q
            >
            <i class="subtitle">7. Этапы Layout и Paint</i>
            <p>Когда Render Tree готов, начинаются этапы самого рендеринга.</p>
            <p>
                Далее происходит вычисление размеров всех элементов на странице и их позиционирование (layout). И после
                этого идет уже процесс отрисовки элементов (paint).
            </p>
            <i class="subtitle">8. Композиция и отображение</i>
            <p>Браузер склеивает слои на GPU и показывает страницу.</p>
            <p>
                Сначала First Paint (белый фон), потом First Contentful Paint (первый текст/картинка), дальше Largest
                Contentful Paint (когда отрисовался самый большой элемент на экране. Это считается ключевым моментом
                «страница реально загрузилась для пользователя»). Эти этапы хорошо видны, если включить в режиме
                разработчика искусственное ограничение скорости интернета.
            </p>
            <q
                >GPU (Graphics Processing Unit) — видеокарта, чип, который умеет быстро рисовать графику. Браузер
                использует её, чтобы собирать слои страницы, обрабатывать анимации и эффекты (тени, трансформации). Это
                разгружает CPU (центральный процессор).</q
            >`,
    selected: false,
    lastUpdate: '29.09.2025',
};
