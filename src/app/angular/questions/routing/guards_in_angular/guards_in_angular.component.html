<mat-accordion>
    <mat-expansion-panel
        (opened)="panelOpenState = true"
        (closed)="panelOpenState = false"
    >
        <mat-expansion-panel-header>
            <mat-panel-title>
                Как разрешается или запрещается переход по указанному маршруту
                (защищенные пути)?
            </mat-panel-title>
        </mat-expansion-panel-header>
        <p>
            Разрешать или ограничивать доступ к тем или иным маршрутам на основе
            определенных условий мы можем с помощью <code>Route Guards</code>,
            которые
            <span class="attention">
                представляют из себя обычные классы или функции, реализующие
                определенный интерфейс.
            </span>
        </p>
        <p>
            Причем важной чертой <code>Guards</code> является то, что<span
                class="attention"
            >
                они всегда должны возвращать либо
            </span>
            <code>true</code><span class="attention">, либо</span>
            <code>false</code> в зависимости от каких-либо условий, будь они
            синхронные или асинхронные. И если будет возвращено
            <code>false</code>, будет инициировано событие маршрутизации
            <code>NavigationCancel</code>, которое не даст перейти по заданному
            маршруту.
        </p>
        <pre><code><span class="export">export</span> <span class="keyword">class</span> <span class="class-name">AuthGuard</span> <span class="keyword">implements</span> <span class="interface-name">CanActivate</span> <span class="punctuation">{{'{'}}</span>
	<span class="method">canActivate</span><span class="punctuation">(</span>
		route: <span class="class-name">ActivatedRouteSnapshot</span>,
		state: <span class="class-name">RouterStateSnapshot</span><span class="punctuation">)</span>: <span class="type">Observable<</span><span class="type">boolean | UrlTree> | </span><span class="type">Promise<</span><span class="type">boolean | UrlTree> |</span> <span class="type">boolean | UrlTree</span> <span class="punctuation">{{'{'}}</span>
    	<span class="keyword">return</span> <span class="boolean">true</span>;
	<span class="punctuation">{{'}'}}</span>  
<span class="punctuation">{{'}'}}</span></code></pre>
        <p>Существуют следующие виды <code>Guards</code>:</p>
        <ul>
            <li>
                <span class="attention">CanMatch</span> - отображает или
                скрывает возможный маршрут; Например, если
                <code>CanMatch</code> вернул вам <code>false</code>, то при
                переходе на указанный адрес, Angular выдаст вам ошибку 404, если
                не стоит обработка несуществующих путей в маршрутизаторе;
            </li>
            <li>
                <span class="attention">CanLoad</span> - разрешает или запрещает
                загрузку модуля, загружаемого асинхронно;
            </li>
            <li>
                <span class="attention">CanDeactivate</span> - разрешает или
                запрещает уход с текущего маршрута. Обычно используется для
                подтверждения ухода пользователя со страницы, где могут остаться
                несохраненные данные;
            </li>
            <li>
                <span class="attention">CanActivateChild</span> - разрешает или
                запрещает доступ к дочернему маршруту;
            </li>
            <li>
                <span class="attention">CanActivate</span> - разрешает или
                запрещает доступ к маршруту;
            </li>
            <li>
                <span class="attention">Resolve</span> - выполняет какое-либо
                действие перед переходом на маршрут, обычно ожидает данные от
                сервера;
            </li>
        </ul>
        <p>
            В списке выше <code>Guards</code> расположены в порядке срабатывания
            проверок, за исключением <code>Resolve</code>, он живет немного по
            своим условиям. Об этом чуть ниже.
        </p>
        <p>
            У одного URL может быть одновременно несколько guard-ов, причем
            одного и того же типа.
        </p>
        <pre><code><span class="keyword">const</span> <span class="variable">routes</span>: <span class="type">Routes</span> <span class="operator">=</span> <span class="punctuation">[</span>
	<span class="punctuation">{{'{'}}</span>
		<span class="key">path</span>: <span class="string">'products'</span>,
		<span class="key">component</span>: <span class="class-name">ProductsComponent</span>,
		<span class="key">canActivate</span>: <span class="punctuation">[</span><span class="class-name">AuthGuard</span><span class="punctuation">]</span>, <span class="comment">// Guard для родительского компонента</span>
    	<span class="key">canActivateChild</span>: <span class="punctuation">[</span><span class="class-name">AuthGuard</span><span class="punctuation">]</span>, <span class="comment">// Guard для дочерних компонентов</span>
		<span class="key">children</span>: <span class="punctuation">[{{'{'}}</span>
			<span class="key">path</span>: <span class="string">'product/:id'</span>,
			<span class="key">component</span>: <span class="class-name">ProductComponent</span>
		<span class="punctuation">{{'}'}}]</span>,
	<span class="punctuation">{{'}'}}</span>,
<span class="punctuation">]</span></code></pre>
        <p>
            Вернемся к событию <code>Resolve</code>. Обычно данное событие
            используется, когда переход на указанный маршрут надо осуществить
            или отклонить в зависимости от результата, который надо "подождать".
            В таких случаях уже используется сервис <code>Resolver</code>.
        </p>
        <p>
            <code>Resolver</code> - это сервис, реализующий интерфейс
            <code>Resolve</code>, а именно метод <code>resolve</code>, который
            <span class="attention"
                >обязательно должен возвращать данные типа</span
            >
            <code>Observable</code>. Указанный для любого маршрута,
            <code>Resolver</code> разрешает переход на него после выполнения
            <code>Observable</code> в <code>resolve</code>.
        </p>
        <pre><code><span class="export">export</span> <span class="keyword">class</span> <span class="class-name">AuthResolver</span> <span class="keyword">implements</span> <span class="interface-name">Resolve</span><span class="type">{{'<'}}boolean></span> <span class="punctuation">{{'{'}}</span>
    <span class="method">resolve</span><span class="punctuation">(</span>
        route: <span class="type">ActivatedRouteSnapshot</span>,
        state: <span class="type">RouterStateSnapshot</span>
    <span class="punctuation">)</span>: <span class="type">Observable{{'<'}}boolean></span> <span class="punctuation">{{'{'}}</span>
        <span class="keyword">return</span> <span class="method">of</span><span class="punctuation">(</span><span class="boolean">true</span><span class="punctuation">)</span>;
    <span class="punctuation">{{'}'}}</span>
<span class="punctuation">{{'}'}}</span></code></pre>
        <p>
            Выполнение метода <code>resolve</code> (как синхронного, так и
            асинхронного) инициирует событие <code>NavigationEnd</code>, что
            можно использовать для скрытия прелоадера при переходах между
            страницами.
        </p>
    </mat-expansion-panel>
</mat-accordion>
