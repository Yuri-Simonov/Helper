<mat-accordion>
    <mat-expansion-panel
        (opened)="panelOpenState = true"
        (closed)="panelOpenState = false"
    >
        <mat-expansion-panel-header>
            <mat-panel-title>
                Какие существуют способы отписки от "subscribe"?
            </mat-panel-title>
        </mat-expansion-panel-header>
        <p>
            Небольшой вступительный пример того, как делаются отписки от
            какого-либо события в нативном JavaScript:
        </p>
        <pre><code><span class="comment">// создаем функцию, которая будет делать подписку на setTimeout</span>
<span class="keyword">function</span> <span class="function-name">timer</span><span class="punctuation">(</span>cb, timeout<span class="punctuation">)</span> <span class="punctuation">{{'{'}}</span>
    <span class="keyword">const</span> <span class="variable">timeoutId</span> <span class="operator">=</span> <span class="function-name">setTimeout</span><span class="punctuation">(</span>cb, timeout<span class="punctuation">)</span>;
    <span class="keyword">return</span> <span class="punctuation">()</span> <span class="operator">=></span> <span class="function-name">clearInterval</span><span class="punctuation">(</span>timeoutId<span class="punctuation">)</span>;
<span class="punctuation">{{'}'}}</span>
<span class="comment">// замыкаем в переменную disposeTimer функцию, которая отменит подписку</span>
<span class="keyword">const</span> <span class="variable">disposeTimer</span> <span class="operator">=</span> <span class="function-name">timer</span><span class="punctuation">(</span>someFunction, <span class="number">1000</span><span class="punctuation">)</span>;
<span class="comment">// отменяем подписку</span>
<span class="function-name">disposeTimer()</span>;</code></pre>
        <p>Перейдем теперь непосредственно к RxJs.</p>
        <i class="subtitle">Сохранить подписку в переменную</i>
        <p>
            Самый простой способ отписаться от подписки - сохранить подписку в
            переменную и вызвать у нее метод <code>unsubscribe</code>, когда
            подписка нам уже не нужна:
        </p>
        <pre><code><span class="keyword">const</span> <span class="variable">subsTimer</span>: <span class="type">Subscription</span> <span class="operator">=</span> <span class="function-name">timer</span><span class="punctuation">(</span><span class="number">1000</span><span class="punctuation">)</span>.<span class="method">subscribe()</span>;
<span class="variable">subsTimer</span>.<span class="method">unsubscribe()</span>;</code></pre>
        <p>
            В примере выше нам необходимо следить за каждой подпиской. То есть,
            сохранять ее в переменную и затем где-то вызывать метод
            <code>unsubscribe</code>, что потом избавиться от подписки. Когда
            подписок много в компоненте, то становится очень много однообразного
            кода.
        </p>
        <i class="subtitle">takeUntil</i>
        <p>
            Другой способ, который находит более широкое на практике - это
            использовать <code>ReplaySubject</code> и оператор
            <code>takeUntil</code> для отписки сразу от всех подписок:
        </p>
        <pre><code>onDestroy: <span class="type">ReplaySubject{{'<'}}any></span> <span class="operator">=</span> <span class="keyword">new</span> <span class="class-name">ReplaySubject</span><span class="type">{{'<'}}any></span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">)</span>;

<span class="method">ngOninit()</span> <span class="punctuation">{{'{'}}</span>
	<span class="object">this</span>.control.valueChanges
		.<span class="method">pipe</span><span class="punctuation">(</span>
			<span class="comment">// switchMap отписывается от старого Observable и подписывается на новый, который приходит из сервиса</span>
			<span class="comment">// это, кстати, еще один способ отписаться от события</span>
			<span class="function-name">switchMap((</span>userId<span class="punctuation">)</span> <span class="operator">=></span> <span class="object">this</span>.service.<span class="method">getUser(</span>userId<span class="punctuation">))</span>,
			<span class="comment">// берем данные пока компонент существует</span>
			<span class="function-name">takeUntil</span><span class="punctuation">(</span><span class="object">this</span>.onDestroy<span class="punctuation">)</span>
		<span class="punctuation">)</span>
		.<span class="method">subscribe()</span>;
<span class="punctuation">{{'}'}}</span>

<span class="method">ngOnDestroy()</span> <span class="punctuation">{{'{'}}</span>
	<span class="comment">// в момент уничтожения компонента избавляемся от подписок</span>
	<span class="object">this</span>.onDestroy.<span class="method">next(</span><span class="null">null</span><span class="punctuation">)</span>;
	<span class="object">this</span>.onDestroy.<span class="method">complete()</span>;
<span class="punctuation">{{'}'}}</span></code></pre>
        <p>
            Вместо <code>ReplaySubject</code> можно использовать и просто
            <code>Subject</code>, но лучше все же использовать именно
            <code>ReplaySubject</code>, т.к. он сделает эмит последнего
            сообщения на случай, если подписка будет создана после уничтожения
            компонента.
        </p>
    </mat-expansion-panel>
</mat-accordion>
