<mat-accordion>
    <mat-expansion-panel
        (opened)="panelOpenState = true"
        (closed)="panelOpenState = false"
    >
        <mat-expansion-panel-header>
            <mat-panel-title>
                Объясните принцип работы декоратора "@SkipSelf()"?
            </mat-panel-title>
        </mat-expansion-panel-header>
        <p>
            Сервисы могут быть определены на трех уровнях и, когда компонент
            запрашивает сервис, то
            <span class="attention">
                поиск начинается с нижних уровней и затем вверх по
                иерархии</span
            >:
        </p>
        <ul>
            <li>
                <span class="attention">Уровень компонента</span> - сначала
                Angular будет искать вызываемый сервис здесь;
            </li>
            <li>
                <span class="attention">Уровень модуля</span> - потом в
                родительском модуле, если не найдет в компоненте;
            </li>
            <li>
                <span class="attention">Уровень приложения</span> - и если все
                еще не нашел, то будет осуществляться поиск в корневом модуле.
                Если и здесь не найдется определение сервиса, то будет
                сгенерирована ошибка.
            </li>
        </ul>
        <p>
            Допустим, вы определили сервис на уровне компонента, но вам нужен
            тот же самый сервис, который определен на уровне приложения. В этом
            вам и поможет декоратор <code>@SkipSelf()</code>.
        </p>
        <p>
            Иначе говоря, если указать <code>@SkipSelf()</code> в конструкторе
            перед нужным сервисом, то
            <span class="attention">
                поиск сервиса на этом уровне будет исключен из поиска.
            </span>
        </p>
        <pre><code><span class="keyword">@Component</span><span class="punctuation">{{'({'}}</span>
	<span class="key">selector</span>: <span class="string">'app-some-component'</span>,
	<span class="key">templateUrl</span>: <span class="string">'./some.component.html'</span>,
	<span class="key">providers</span>: <span class="punctuation">[</span><span class="service-name">SomeService</span><span class="punctuation">]</span>, <span class="comment">// добавление сервиса на уровне компонента</span>
<span class="punctuation">{{'})'}}</span>
<span></span>
<span class="export">export</span> <span class="keyword">class</span> <span class="class-name">SomeComponent</span> <span class="punctuation">{{'{'}}</span>
	<span class="keyword">constructor</span><span class="punctuation">(</span><span class="keyword">@SkipSelf()</span> <span class="keyword">private</span> someService: <span class="class-name">SomeService</span><span class="punctuation">)</span> <span class="punctuation">{{'{}'}}</span>
<span class="punctuation">{{'}'}}</span></code></pre>
        <p>
            Исходя из вышесказанного, можно сделать следующий трюк: если указать
            два одинаковых сервиса в одном компоненте, но перед одним из них
            поставить <code>@SkipSelf()</code>, то удастся получить доступ к
            локальному и глобальному экземплярам одновременно.
        </p>
    </mat-expansion-panel>
</mat-accordion>
